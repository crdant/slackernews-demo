name: branding

on:
  workflow_dispatch:
    inputs:
      slug:
        description: Replicated App Slug
        required: true
        type: string
      api-token:
        description: Replicated API Token
        required: false
        type: string
      api-origin:
        description: Replicated API Origin
        required: false
        default: https://api.replicated.com/vendor
        type: string

jobs:
  prepare:
    runs-on: ubuntu-22.04
    outputs:
      app-id: ${{ steps.app-id.outputs.app-id }}
    steps:
      - name: Install Replicated CLI
        run: |
          curl -sSL https://raw.githubusercontent.com/replicatedhq/replicated/master/install.sh \
            | sudo bash

      - name: Fetch the application ID from the slug
        id: app-id
        run: |
          app_id=$(replicated app ls --output json | jq -r --arg slug "${{ inputs.slug }}" '.[] | select ( .app.slug == $slug ) | .app.id')
          echo "app-id=${app_id}" >> $GITHUB_OUTPUT
        env:
          REPLICATED_API_TOKEN: ${{ inputs.api-token || secrets.REPLICATED_API_TOKEN }}
          REPLICATED_API_ORIGIN: ${{ inputs.api-origin || 'https://api.replicated.com/vendor' }}

  portal:
    runs-on: ubuntu-22.04
    needs: 
      - prepare
    steps:
      - name: Install Replicated CLI
        run: |
          curl -sSL https://raw.githubusercontent.com/replicatedhq/replicated/master/install.sh \
            | sudo bash

      - name: Checkout branding
        uses: actions/checkout@v4
      
      - name: Setup yq
        uses: mikefarah/yq@master
      
      - name: Process images and convert YAML branding to JSON
        run: |
          # Create a temporary file to work with
          cp branding/enterprise-portal/branding.yaml branding/enterprise-portal-temp.yaml
          
          # Function to convert URL or file path to data URL
          convert_to_data_url() {
            local field=$1
            local value=$(yq eval ".branding.$field" branding/enterprise-portal-temp.yaml)
            
            # Check if it's already a data URL or empty
            if [[ "$value" == "data:"* ]] || [[ "$value" == '""' ]] || [[ "$value" == "null" ]]; then
              return
            fi
            
            local source_file=""
            
            # Check if it's an HTTP/HTTPS URL
            if [[ "$value" == "http"* ]]; then
              # Download the file
              source_file=$(mktemp)
              if ! curl -L -s -o "$source_file" "$value"; then
                echo "Failed to download $field from $value"
                rm -f "$source_file"
                exit 1
              fi
            elif [[ -f "branding/enterprise-portal/$value" ]]; then
              # It's a local file path relative to the branding.yaml location
              source_file="branding/enterprise-portal/$value"
            elif [[ -f "$value" ]]; then
              source_file="$value"
            else
              return
            fi
            
            # Process the file (whether downloaded or local)
            if [[ -f "$source_file" ]]; then
              # Detect content type
              content_type=$(file --mime-type -b "$source_file")
              
              # Convert to base64 and create data URL
              base64_data=$(base64 -w 0 "$source_file")
              data_url="data:$content_type;base64,$base64_data"
              
              # Update the YAML file
              yq eval ".branding.$field = \"$data_url\"" -i branding/enterprise-portal-temp.yaml
              
              # Clean up downloaded file (but not local files)
              if [[ "$value" == "http"* ]]; then
                rm -f "$source_file"
              fi
            else
              echo "File not found for $field: $source_file"
              exit 1
            fi
          }
          
          # Convert logo and favicon if they are URLs or local files
          convert_to_data_url "logo"
          convert_to_data_url "favicon"
          
          # Process documentation if it exists
          if [[ -f "branding/enterprise-portal/documentation.yaml" ]]; then
            echo "Processing documentation configuration..."
            
            # Function to read markdown file content and add to YAML
            process_doc_field() {
              local field=$1
              local value=$(yq eval ".documentation.$field" branding/enterprise-portal/documentation.yaml)
              
              # Skip if field doesn't exist or is empty
              if [[ "$value" == "null" ]] || [[ "$value" == '""' ]]; then
                return
              fi
              
              # Check if it's a file reference (not a URL)
              if [[ ! "$value" == "http"* ]] && [[ -f "branding/enterprise-portal/$value" ]]; then
                echo "Reading markdown content for $field from $value"
                # Use yq to properly set the content from file
                yq eval ".branding.$field = load_str(\"branding/enterprise-portal/$value\")" -i branding/enterprise-portal-temp.yaml
              elif [[ "$value" == "http"* ]]; then
                # It's a URL, add it directly
                yq eval ".branding.$field = \"$value\"" -i branding/enterprise-portal-temp.yaml
              fi
            }
            
            # Process all documentation fields
            process_doc_field "helm_install_url"
            process_doc_field "values_override_url"
            process_doc_field "embedded_cluster_install_url"
            process_doc_field "kurl_install_url"
            process_doc_field "kots_install_url"
            process_doc_field "helm_pre_install"
            process_doc_field "helm_post_install"
            process_doc_field "embedded_cluster_pre_install"
            process_doc_field "embedded_cluster_post_install"
          fi
          
          # Convert the processed YAML to JSON format expected by API
          yq eval '{"branding": (.branding | @json | @base64)}' branding/enterprise-portal-temp.yaml -o json > branding/enterprise-portal-processed.json
          
          # If documentation exists, create separate documentation payload
          if [[ -f "branding/enterprise-portal/documentation.yaml" ]]; then
            # Create documentation-specific payload with only doc fields from temp YAML
            yq eval '{
              "documentation": {
                "helmInstallUrl": .branding.helm_install_url,
                "valuesOverrideUrl": .branding.values_override_url,
                "embeddedClusterInstallUrl": .branding.embedded_cluster_install_url,
                "kurlInstallUrl": .branding.kurl_install_url,
                "kotsInstallUrl": .branding.kots_install_url,
                "helmPreInstall": .branding.helm_pre_install,
                "helmPostInstall": .branding.helm_post_install,
                "embeddedClusterPreInstall": .branding.embedded_cluster_pre_install,
                "embeddedClusterPostInstall": .branding.embedded_cluster_post_install
              }
            }' branding/enterprise-portal-temp.yaml -o json > branding/enterprise-portal-docs.json
            
            # Remove documentation fields from branding payload
            yq eval 'del(.branding.helm_install_url, .branding.values_override_url, .branding.embedded_cluster_install_url, .branding.kurl_install_url, .branding.kots_install_url, .branding.helm_pre_install, .branding.helm_post_install, .branding.embedded_cluster_pre_install, .branding.embedded_cluster_post_install)' -i branding/enterprise-portal-temp.yaml
            yq eval '{"branding": (.branding | @json | @base64)}' branding/enterprise-portal-temp.yaml -o json > branding/enterprise-portal-processed.json
          fi
          
          # Clean up temp file
          rm -f branding/enterprise-portal-temp.yaml

      - name: Setup the Enterprise Portal branding
        run: |
          replicated api put /v3/app/${APP_ID}/enterprise-portal/branding \
            --body "$(cat branding/enterprise-portal-processed.json)"
        env:
          APP_ID: ${{ needs.prepare.outputs.app-id }}
          REPLICATED_API_TOKEN: ${{ inputs.api-token || secrets.REPLICATED_API_TOKEN }}
          REPLICATED_API_ORIGIN: ${{ inputs.api-origin || 'https://api.replicated.com/vendor' }}

      - name: Setup the Enterprise Portal documentation
        if: hashFiles('branding/enterprise-portal/documentation.yaml') != ''
        run: |
          replicated api put /v3/app/${APP_ID}/enterprise-portal/documentation \
            --body "$(cat branding/enterprise-portal-docs.json)"
        env:
          APP_ID: ${{ needs.prepare.outputs.app-id }}
          REPLICATED_API_TOKEN: ${{ inputs.api-token || secrets.REPLICATED_API_TOKEN }}
          REPLICATED_API_ORIGIN: ${{ inputs.api-origin || 'https://api.replicated.com/vendor' }}


  email:
    runs-on: ubuntu-22.04
    needs: 
      - prepare
    steps:
      - name: Checkout branding
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: 'branding/email-templates/package-lock.json'

      - name: Build email templates from MJML sources
        run: |
          cd branding/email-templates
          npm ci
          npm run build

      - name: Setup the Enterprise Portal email templates
        run: |
          curl -X PUT \
            -H "Authorization: ${REPLICATED_API_TOKEN}" \
            -H "Content-Type: application/json" \
            -d @branding/email-templates.json \
            "${REPLICATED_API_ORIGIN}/v3/app/${APP_ID}/enterprise-portal/email-templates"
        env:
          APP_ID: ${{ needs.prepare.outputs.app-id }}
          REPLICATED_API_TOKEN: ${{ inputs.api-token || secrets.REPLICATED_API_TOKEN }}
          REPLICATED_API_ORIGIN: ${{ inputs.api-origin || 'https://api.replicated.com/vendor' }}
